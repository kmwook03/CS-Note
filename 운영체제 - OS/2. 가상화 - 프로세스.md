> ## 프로세스(Process)

일반적으로 프로세스는 **실행 중인 프로그램** 으로 정의한다.
프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음이다. 운영체제는 명령어와 데이터 묶음을 읽고 실행하여 프로그램에 생명을 불어넣는다.

> **핵심 질문**
여러 개의 CPU가 존재한다는 **환상(illusion)** 을 어떻게 제공하는가?

운영체제는 CPU를 **가상화(virtualizing)** 하여 이러한 환상을 만들어낸다. 하나의 프로세스를 실행하고, 중단시키고 다른 프로세스를 실행하는 것을 반복하며 하나 또는 소수의 물리 CPU로 여러 개의 가상 CPU가 존재하는 것 처럼 보이게 한다. CPU의 **시 분할(time sharing)** 이라고 알려진 이런 기본적인 테크닉은 원하는 수 만큼의 프로세스를 동시에 실행할 수 있게 한다.

CPU의 가상화를 구현하기 위해서 OS는 저수준 기계(low-level machinery)와 고수준 지능(high-level intelligence)이 필요하다.

이 저수준 기계를 **메커니즘(mechanism)** 이라 하고 고수준 지능은 **정책(policy)** 의 형태로 표현된다.

- 메커니즘: 문맥 교환(context switch)
- 정책: 스케줄링(scheduling)

### 프로세스의 추상적 개념

운영체제에서 제공하는 **실행 중인 프로그램** 이라는 개념을 **프로세스(process)** 라고 한다.

프로세스의 구성 요소를 이해하기 위해 **하드웨어 상태(machine state)** 를 이해해야 한다.

**1. 메모리(memory)**
프로세스의 하드웨어 상태 중 가장 중요한 구성요소는 **메모리** 다. 명령어는 메모리에 저장되며 실행 중인 프로그램이 읽고 쓰는 데이터 역시 메모리에 저장된다.

**2. 레지스터(register)**
많은 명령어들이 레지스터를 직접 읽고 업데이트 한다. 프로세스의 하드웨어 상태를 구성하는 레지스터 중에 특별한 레지스터가 존재한다.

- **프로그램 카운터(PC) 또는 명령어 포인터(IP)**
어느 명령어가 실행 중인지 알려줌

- **스택 포인터(stack pointer), 프레임 포인터(frame pointer)**
함수의 변수와 리턴 주소를 저장하는 스택 관리에 사용됨

**3. 영구 저장장치(persistent storage)**
입출력 정보는 프로세스가 현재 열어 놓은 파일 목록을 가진다.

>**정책과 구현의 분리**
많은 운영체제에서 공통된 설계 패러다임은 고수준 정책을 저수준 메커니즘으로부터 분리하는 것이다.
메커니즘은 시스템에 관한 **"어떻게(How)"** 에 대한 답을 제공한다.
(예: 어떻게 문맥 교환을 하는가?)
정책은 **"어떤(Which)"** 에 대한 답을 제공한다.
(예: 어느 프로세스를 실행시켜야 하는가?)
이 둘을 분리하면 정책을 변경할 때 메커니즘의 변경을 고민하지 않아도 된다. 즉, **모듈성(modularity)** 의 한 형태이다.

### 프로세스의 생성: 어떻게 프로그램이 프로세스가 되는가

운영체제가 하는 첫 번째 작업은 프로그램 코드와 정적 데이터를 메모리에 **로드(load)** 하는 것이다.

![](https://velog.velcdn.com/images/kmwook/post/2a3ae51a-4c12-4657-8de6-d94a8fa39450/image.png)

프로그램은 디스크 또는 SSD에 특정 실행 파일 형식으로 존재한다. 코드와 데이터를 메모리에 탑재하기 위해서 운영체제는 디스크의 해당 바이트를 읽어서 메모리의 어딘가에 저장해야 한다.
초기 운영체제들은 프로그램 실행 전에 코드와 데이터를 모두 메모리에 탑재하였지만 현대의 운영체제들은 이 작업을 늦추었다. 즉, 프로그램을 실행하면서 코드나 데이터가 **필요할 때 필요한 부분만** 메모리에 탑재한다.

코드와 정적 데이터가 메모리로 탑재된 후, 프로세스를 실행시키기 전에 운영체제는 일정량의 메모리를 **실행시간 스택(run-time stack)** 용도로 할당시키고, 프로그램의 **힙(heap)** 을 위한 메모리 영역도 할당한다.
또한 입출력과 관련된 초기화 작업을 수행한다.

코드와 정적 데이터를 메모리에 탑재하고, 스택과 힙을 생성하고 초기화하고, 입출력 셋업과 관련된 다른 작업을 마치면 운영체제는 프로그램 실행을 위한 준비를 마친다. 이제 프로그램의 **시작 지점(entry point)** 에서부터 프로그램을 실행한다.

### 프로세스 상태

**1. Running**
프로세스가 프로세서에서 실행 중인 상태로 프로세스는 명령어를 실행하고 있다.

**2. Ready**
프로세스는 실행할 준비가 되어 있지만 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 대기 중인 상태다.

**3. Blocked**
프로세스가 다른 이벤트(event)를 기다리는 동안 프로세스의 수행을 중단시킨다.
(예: 입출력 대기)

![](https://velog.velcdn.com/images/kmwook/post/2bc28b66-4007-40e3-a393-9d222d558b25/image.png)

두 개의 프로세스가 어떻게 전이될 수 있는지 다음 표로 살펴보자. 이 예시에서 프로세스는 오직 CPU만 사용하고 입출력을 행하지 않는다.

| `시간` | `P0` | `P1` | `비고` |
|-|-|-|-|
|`1`|`Running`|`Ready`||
|`2`|`Running`|`Ready`||
|`3`|`Running`|`Ready`||
|`4`|`Running`|`Ready`|`P0 실행 종료`|
|`5`|`-`|`Running`||
|`6`|`-`|`Running`||
|`7`|`-`|`Running`||
|`8`|`-`|`Running`|`P1 실행 종료`|

다음으로 살펴볼 예에서는 첫 번째 프로세스가 어느 정도 실행한 후에 입출력을 요청한다. 그 순간 프로세스는 대기 상태가 되고 다른 프로세스에게 실행 기회를 준다.

| `시간` | `P0` | `P1` | `비고` |
|-|-|-|-|
|`1`|`Running`|`Ready`||
|`2`|`Running`|`Ready`||
|`3`|`Running`|`Ready`|`P0 I/O 시작`|
|`4`|`Blocked`|`Running`|`P0 Blocked`|
|`5`|`Blocked`|`Running`|`그에 따라 P1 실행`|
|`6`|`Blocked`|`Running`||
|`7`|`Ready`|`Running`|`I/O 완료`|
|`8`|`Ready`|`Running`|`P1 실행 종료`|
|`9`|`Running`|`-`||
|`10`|`Running`|`-`|`P0 실행 종료`|

P0는 입출력 요청 후 요청한 작업이 완료되기를 기다린다. 이 때 운영체제는 P0가 CPU를 사용하지 않는다는 것을 감지하고 P1을 실행시킨다. P1이 실행되는 동안 입출력이 완료되고 P0는 다시 실행되기 위해 Ready 상태로 전이된다. 이후 P1이 종료되고 P0가 실행된다.
이러한 작업은 운영체제의 스케줄러에 의해 이루어진다.

### 자료 구조(Data Structure)

운영체제도 일종의 프로그램이기 때문에, 다양한 정보들을 관리하기 위한 몇 가지 주요 자료 구조를 가진다.

다수의 프로그램을 동시에 실행할 수 있는 모든 운영체제는 프로세스 상태 파악을 위해 **프로세스 리스트(process list)** 라는 자료 구조를 가진다.
운영체제는 어느 프로세스가 실행 중인지도 파악해야 하고, 대기 상태인 프로세스도 파악해야 한다. 입출력 요청이 완료되면 적절한 프로세스를 깨워 준비 상태로 다시 전이시킬 수 있어야 한다.

다음은 xv6 커널에서 사용하는 위에서 설명한 정보를 담는 자료 구조이다.

```c
// 프로세스를 중단하고 이후에 재개하기 위해
// 저장 및 복원하는 레지스터
struct context {
	int eip;
    int esp;
    int ebx;
    int ecx;
    int edx;
    int esi;
    int edi;
    int ebp;
};

// 가능한 프로세스 상태
enum proc_state { UNUSED, EMBRYO, SLEEPING,
				  RUNNABLE, RUNNING, ZOMBIE };

// 레지스터 문맥과 상태를 포함한 각 프로세스의 정보
struct proc {
	char *mem;					// 프로세스 메모리 시작 주소
    uint sz;					// 프로세스 메모리 크기
    char *kstack;				// 커널 스택 바닥 주소
    enum proc_state state;		// 프로세스 상태
    int pid;					// 프로세스 ID
    struct proc *parent;		// 부모 프로세스
    void *chan;					// 0이 아니면, chan에서 sleeping
    int killed;					// 0이 아니면, kill 됨
    struct file *ofile[NOFILE]; // 열린 파일
    struct inode *cwd;			// 현재 디렉터리
    struct context context;		// 프로세스를 실행 시키려면 여기로 switch
    struct trapframe *tf;		// 현재 인터럽트에 해당하는 트랩 프레임
};

```

Linux, Mac OS, Windows 같은 운영체제들도 이와 비슷한 프로세스 구조를 가지고 있다. 다만, 훨씬 복잡하다.

이 코드를 통해 운영체제가 관리하고 있는 프로세스 정보를 알 수 있다.
**레지스터 문맥(register context)** 자료구조는 프로세스가 중단되었을 때 해당 프로세스의 레지스터 값들을 저장한다. 운영체제는 이 레지스터 값들을 복원하여 프로세스 실행을 재개한다.

실행, 준비, 대기 외에 다른 상태들이 존재하는 것도 볼 수 있다. 프로세스가 생성되는 동안에 머무르는 **초기(initial)** 상태와 프로세스는 종료되었지만 메모리에 남아있는 상태인 **최종(final)** 상태가 추가로 존재한다. UNIX 기반 시스템에서 이 최종 상태를 **좀비(zombie)** 상태라고 부른다. 이 상태는 프로세스가 성공적으로 실행 종료되었는지를 검사하는데 사용된다.


---
<span style="color:gray"><참고자료>
Remzi Arpaci-Dusseau and Andrea C. Arpaci-Dusseau, Operating System: Three Easy Pieces, Arpaci-Dusseau Books </span>