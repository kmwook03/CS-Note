## 프로세스(Process)

일반적으로 프로세스는 **실행 중인 프로그램**으로 정의한다.
프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음이다. 운영체제는 명령어와 데이터 묶음을 읽고 실행하여 프로그램에 생명을 불어넣는다.

> **핵심 질문**
여러 개의 CPU가 존재한다는 **환상(illusion)**을 어떻게 제공하는가?

운영체제는 CPU를 가상화(virtualizing)하여 이러한 환상을 만들어낸다. 하나의 프로세스를 실행하고, 중단시키고 다른 프로세스를 실행하는 것을 반복하며 하나 또는 소수의 물리 CPU로 여러 개의 가상 CPU가 존재하는 것 처럼 보이게 한다. CPU의 **시 분할(time sharing)**이라고 알려진 이런 기본적인 테크닉은 원하는 수 만큼의 프로세스를 동시에 실행할 수 있게 한다.

CPU의 가상화를 구현하기 위해서 OS는 저수준 기계(low-level machinery)와 고수준 지능(high-level intelligence)이 필요하다.

이 저수준 기계를 **메커니즘(mechanism)**이라 하고 고수준 지능은 **정책(policy)**의 형태로 표현된다.

- 메커니즘: 문맥 교환(context switch)
- 정책: 스케줄링(scheduling)

### 프로세스의 추상적 개념

운영체제에서 제공하는 **실행 중인 프로그램**이라는 개념을 **프로세스(process)**라고 한다.

프로세스의 구성 요소를 이해하기 위해 **하드웨어 상태(machine state)**를 이해해야 한다.

**1. 메모리(memory)**
프로세스의 하드웨어 상태 중 가장 중요한 구성요소는 **메모리**다. 명령어는 메모리에 저장되며 실행 중인 프로그램이 읽고 쓰는 데이터 역시 메모리에 저장된다.

**2. 레지스터(register)**
많은 명령어들이 레지스터를 직접 읽고 업데이트 한다. 프로세스의 하드웨어 상태를 구성하는 레지스터 중에 특별한 레지스터가 존재한다.

- **프로그램 카운터(PC) 또는 명령어 포인터(IP)**
어느 명령어가 실행 중인지 알려줌

- **스택 포인터(stack pointer), 프레임 포인터(frame pointer)**
함수의 변수와 리턴 주소를 저장하는 스택 관리에 사용됨

**3. 영구 저장장치(persistent storage)**
입출력 정보는 프로세스가 현재 열어 놓은 파일 목록을 가진다.

>**정책과 구현의 분리**
많은 운영체제에서 공통된 설계 패러다임은 고수준 정책을 저수준 메커니즘으로부터 분리하는 것이다.
메커니즘은 시스템에 관한 **"어떻게(How)"**에 대한 답을 제공한다.
(예: 어떻게 문맥 교환을 하는가?)
정책은 **"어떤(Which)"**에 대한 답을 제공한다.
(예: 어느 프로세스를 실행시켜야 하는가?)
이 둘을 분리하면 정책을 변경할 때 메커니즘의 변경을 고민하지 않아도 된다. 즉, **모듈성(modularity)**의 한 형태이다.

### 프로세스의 생성: 어떻게 프로그램이 프로세스가 되는가

운영체제가 하는 첫 번째 작업은 프로그램 코드와 정적 데이터를 메모리에 **로드(load)**하는 것이다.


프로그램은 디스크 또는 SSD에 특정 실행 파일 형식으로 존재한다. 코드와 데이터를 메모리에 탑재하기 위해서 운영체제는 디스크의 해당 바이트를 읽어서 메모리의 어딘가에 저장해야 한다.
초기 운영체제들은 프로그램 실행 전에 코드와 데이터를 모두 메모리에 탑재하였지만 현대의 운영체제들은 이 작업을 늦추었다. 즉, 프로그램을 실행하면서 코드나 데이터가 **필요할 때 필요한 부분만** 메모리에 탑재한다.

코드와 정적 데이터가 메모리로 탑재된 후, 프로세스를 실행시키기 전에 운영체제는 일정량의 메모리를 **실행시간 스택(run-time stack)** 용도로 할당시키고, 프로그램의 **힙(heap)**을 위한 메모리 영역도 할당한다.
또한 입출력과 관련된 초기화 작업을 수행한다.

코드와 정적 데이터를 메모리에 탑재하고, 스택과 힙을 생성하고 초기화하고, 입출력 셋업과 관련된 다른 작업을 마치면 운영체제는 프로그램 실행을 위한 준비를 마친다. 이제 프로그램의 **시작 지점(entry point)**에서부터 프로그램을 실행한다.

### 프로세스 상태

**1. Running**
프로세스가 프로세서에서 실행 중인 상태로 프로세스는 명령어를 실행하고 있다.

**2. Ready**
프로세스는 실행할 준비가 되어 있지만 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 대기 중인 상태다.

**3. Blocked**
프로세스가 다른 이벤트(event)를 기다리는 동안 프로세스의 수행을 중단시킨다.
(예: 입출력 대기)


두 개의 프로세스가 어떻게 전이될 수 있는지 다음 표로 살펴보자.

| `시간` | `P0` | `P1` | `비고` |
|-|-|-|-|
|`1`|`Running`|`Ready`||
|`2`|`Running`|`Ready`||
|`3`|`Running`|`Ready`||
|`4`|`Running`|`Ready`|`P0 실행 종료`|
|`5`|`-`|`Running`||
|`6`|`-`|`Running`||
|`7`|`-`|`Running`||
|`8`|`-`|`Running`|`P1 실행 종료`|

---
<span style="color:gray"><참고자료>
Remzi Arpaci-Dusseau and Andrea C. Arpaci-Dusseau, Operating System: Three Easy Pieces </span>