
> ## UNIX 시스템의 프로세스 생성

이번 절에서 우리가 다룰 핵심 질문은 다음과 같다.

> **어떻게 프로세스를 생성하고 제어하는가?**
프로세스를 생성하고 제어하려면 운영체제가 어떤 인터페이스를 제공해야 하는가?
유용하고 편한 사용을 위해 이 인터페이스는 어떻게 설계되어야 하는가?

### fork() 시스템 콜

프로세스 생성을 위해서 `fork()` 시스템 콜이 사용된다.
우선 다음 코드를 살펴보자.

`p1.c`
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
	printf("hello (pid: %d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) {
    	// fork failed
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) {
    	// child (new process)
        printf("child (pid: %d)\n", (int) getpid());
    } else {
    	// parent goes down this path (main)
        printf("parent of %d (pid: %d)\n", rc, (int) getpid());
    }
    return 0;
}

```

![](https://velog.velcdn.com/images/kmwook/post/974de013-6d41-4f95-8528-5417ad183f53/image.png)

위 프로그램이 실행되면, 프로세스는 PID(process identifier)와 함께 hello 메시지를 출력한다. UNIX 시스템에서 PID는 프로세스의 실행이나 중단과 같이 특정 프로세스를 대상으로 작업을 해야 할 경우 그 프로세스를 지칭하기 위해 사용된다.

이 프로세스는 운영체제에서 프로세스 생성을 위해 제공하는 `fork()` 시스템 콜을 호출한다. 그런데, 이렇게 생성된 프로세스는 호출한 프로세스의 복사본이라는 이상한 점이 있다. 우리가 주목해야할 점은, `fork()`로 생성된 프로세스는 `main()` 함수의 첫 부분부터 시작하지 않고 `fork()` 이후 부터 시작되었다는 점이다.

자식 프로세스는 부모 프로세스와 완전히 동일하지 않다. 자신의 주소 공간, 레지스터, PC 값을 갖는다. 그리고 fork() 시스템 콜의 반환 값이 서로 다르다. (단, 파일 디스크립터는 공유한다.)

부모 프로세스는 `fork()`로 부터 **자식 프로세스의 PID 값** 을 반환 받고, 자식 프로세스는 **0** 을 반환 받는다.

부모 프로세스와 자식 프로세스 중 어떤 것이 먼저 실행될 지는 **CPU 스케줄러(scheduler)** 에 의해서 결정되므로 항상 같은 순서가 나온다고 보장할 수 없다.

### wait() 시스템 콜

때로는, 부모 프로세스가 자식 프로세스의 종료를 대기해야하는 경우도 발생할 수 있다. 이러한 작업을 위해 `wait()` 시스템 콜 또는 `waitpid()` 시스템 콜을 사용한다.
다음 코드를 살펴보자.

`p2.c`
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
    printf("hello (pid: %d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) {
        printf("child (pid: %d)\n", (int) getpid());
    } else {
        int rc_wait = wait(NULL);
        printf("parent of %d (rc_wait: %d) (pid: %d)\n", rc, rc_wait, (int) getpid());
    }

    return 0;
}

```

![](https://velog.velcdn.com/images/kmwook/post/41730867-08d1-424b-91d5-fd804e4a7e11/image.png)

위 프로그램에서 부모 프로세스는 `wait()` 시스템 콜을 호출하여 자식 프로세스 종료 시점까지 자신의 실행을 잠시 중지시킨다. 자식 프로세스가 종료되면 `wait()`는 리턴한다.
`wait()` 시스템 콜을 사용하면 프로그램이 항상 동일한 결과를 출력하도록 할 수 있다.

### exec() 시스템 콜

자기 자신이 아닌 다른 프로그램을 실행해야 할 때 사용하는 시스템 콜이다. 위에서 살펴봤던 `p2.c`의 `fork()` 시스템 콜은 자신의 복사본을 생성하여 실행한다. 자신의 복사본이 아닌 다른 프로그램을 실행해야 할 경우에 `exec()` 시스템 콜을 사용할 수 있다.
다음 코드를 살펴보자.

`p3.c`
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
	printf("hello (pid: %d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) {
    	fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) {	// child (new process)
    	printf("child (pid: %d)\n", (int) getpid());
        char *myargs[3];
        myargs[0] = strdup("wc");	// program: "wc"
        myargs[1] = strdup("p3.c");	// arg: input file
        myargs[2] = NULL;			// mark end of array
        execvp(myargs[0], myargs);	// runs word count
        printf("this shouldn't print out");
    } else {
    	int rc_wait = wait(NULL);
        printf("parent of %d (rc_wait: %d) (pid: %d)\n", rc, rc_wait, (int) getpid());
    }
    
    return 0;
}

```

![](https://velog.velcdn.com/images/kmwook/post/5b4ccf9c-a59b-439e-8075-652d303cb2e7/image.png)

위 프로그램에서 자식 프로세스는 `wc` 프로그램을 실행하기 위해 `execvp()` 시스템 콜을 호출한다. `wc`는 단어의 개수를 세는 프로그램이다. 이 예제 프로그램은 자기 자신의 소스코드인 `p3.c`를 인자로 하여 `wc`를 실행하고 소스 코드의 행 개수, 단어의 개수, 바이트 개수를 알려주는 프로그램인 것이다.

`exec()` 시스템 콜은 실행 파일의 이름과 인자가 주어지면 해당 실행 파일의 코드와 정적 데이터를 읽어 들여 현재 실행 중인 프로세스의 코드 세그먼트와 정적 데이터 부분을 덮어 쓴다. 힙과 스택 및 다른 메모리 주소 공간들은 새로운 프로그램 실행을 위해 다시 초기화 된다. 즉, 현재 실행 중인 프로그램(`p3`)을 다른 프로그램(`wc`)으로 대체하는 것으로 새로운 프로세스를 생성하는 것은 아니다. 따라서 자식 프로세스가 `exec()`을 호출한 후에는 `p3.c`는 리턴하지 않는다.

### 왜 이런 API를 사용하는가?

> **Getting It Right (Labson's Law)**
_Hints for Computer System Design_의 저자 _Butler W. Lampson_ 이 말한 바와 같이 **"올바르게 선택하라. 추상화도 단순함도 올바른 선택을 대체할 수 없다."**
프로세스 생성을 위한 API를 설계하는 방법은 많다. 그러나 `fork()`와 `exec()`의 조합은 단순하면서 매우 강력하다. UNIX 설계자들은 단순하고 올바른 방법으로 구현하였다.

**쉘(shell)** 은 단순한 사용자 프로그램이다. 쉘은 프롬프트를 표시하고 사용자가 무언가 입력하기를 기다린다.
대부분의 경우 쉘은 파일 시스템에서 실행 파일의 위치를 찾고 명령어를 실행하기 위하여 `fork()`를 호출하여 새로운 자식 프로세스를 만든다. 그런 후 `exec()`의 변형 중 하나를 호출하여 프로그램을 실행시킨 후 `wait()`를 호출하여 명령어가 끝나기를 기다린다. 자식 프로세스가 종료되면 쉘은 `wait()`로부터 리턴하고 다시 프롬프트를 출력한 다음 명령어를 기다린다.

이러한 쉘의 역할을 고려했을 때, `fork()`와 `exec()`의 분리는 필수적이다.
다음 명령어의 결과를 생각해보자.

```bash
wc p3.c > newfile.txt
```

![](https://velog.velcdn.com/images/kmwook/post/4e3968de-69fa-4bc2-a618-c538cc0663ee/image.png)

이 명령어에서 `wc` 프로그램의 출력은 `newfile.txt`라는 출력 파일로 방향이 지정된다.

이러한 작업을 수행하는 방법을 생각해보자.
자식이 생성되고 `exec()`이 호출되기 전에 표준 출력(standard output) 파일을 닫고 newfile.txt 파일을 연다. 이런 작업을 해놓으면 곧 실행될 프로그램인 wc의 출력은 화면이 아니라 파일로 보내진다.

위 명령어의 작업을 수행하는 프로그램은 아래와 같다.
`p4.c`
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
  int rc = fork();
  if (rc < 0) {
    fprintf(stderr, "fork failed\n");
    exit(1);
  } else if (rc == 0) {
    // child: redirect standard output to a file
    close(STDOUT_FILENO);
    open("./p4.output", O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);
    char *myargs[3];
    myargs[0] = strdup("wc");
    myargs[1] = strdup("p4.c");
    myargs[2] = NULL;
    execvp(myargs[0], myargs);
  } else {
    int rc_wait = wait(NULL);
  }
  return 0;
}
```

![](https://velog.velcdn.com/images/kmwook/post/23508e5d-e009-42cd-9787-031e4427072a/image.png)

UNIX 시스템은 미사용 중인 파일 디스크립터를 0번부터 찾아 나간다. 이 경우, 표준 출력 파일을 닫았기 때문에 `STDOUT_FILENO`가 첫 번째 사용 가능 파일 디스크립터로 탐색되어 `open()`이 호출될 때 할당된다. 이후 자식 프로세스가 표준 출력 파일 디스크립터를 대상으로 하는 모든 쓰기 작업은 화면이 아니라 새로 열린 파일로 향하게 된다.

이 출력 결과에는 두 가지 흥미로운 점이 있다. 먼저, `p4`를 실행하면 화면에 아무 일도 일어나지 않지만 실제로는 다음과 같은 일이 발생하였다. 프로그램 `p4`는 `fork()`를 호출하여 새로운 자식 프로세스를 생성하고 `execvp()`를 호출하여 `wc` 프로그램을 실행시킨다. 출력이 `p4.output` 파일로 재지정되었기 때문에 화면에는 아무 것도 출력되지 않는다.

UNIX의 **파이프(`|`)** 가 이와 유사한 방식으로 구현되지만, 이는 **`pipe()`** 시스템 콜을 통하여 생성된다. 이 경우, 한 플세스의 출력과 다른 프로세스의 입력이 동일한 파이프에 연결되어 이전 프로세스의 출력이 다음 프로세스의 입력으로 사용된다.

본 챕터에서는 UNIX 프로세스를 다루는 API 중 기본적이고 중요한 몇 가지만 살펴보았다. 다음 게시글 부터는 다시 CPU 가상화 원리에 대해 자세히 살펴보겠다.

---
<span style="color:gray"><참고자료>
Remzi Arpaci-Dusseau and Andrea C. Arpaci-Dusseau, Operating System: Three Easy Pieces, Arpaci-Dusseau Books </span>