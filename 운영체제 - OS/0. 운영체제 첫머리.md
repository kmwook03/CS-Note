## 운영체제(OS; Operating System)

> 프로그램이 실행될 때, 프로세서(Processor)는 명령어 메모리에서 명령어를 fetch하고, decode하고, execute한다. 해당 명령어의 작업이 완료되면 프로세서는 다음 명령어로 프로그램이 완전히 종료될 때 까지 이 과정을 반복한다.
듣기에는 간단해 보이는 이런 과정을 위해 우리에게 보이지 않는 부분에서 정말 많은 일이 일어나고 있다.

프로그램 사용을 쉽게 만들기 위해 프로그램들이 메모리를 공유하는 것을 허용하고, 다른 기기와 상호작용할 수 있게 만드는 등의 작업을 수행하는 소프트웨어를 **운영체제(OS; Operating System)** 라고 한다.

### 가상화 (Virtualization)

운영체제는 물리 자원(physical resource)을 더 범용적이고 사용하기 쉬운 가상 자원(virtual resource)으로 변환한다. 사용자는 운영체제에서 제공하는 인터페이스(APIs)를 호출하여  명령을 내릴 수 있다.

> **핵심 질문: 어떻게(HOW) 자원을 가상화 하는가?**
우리는 지금부터 Why가 아닌 HOW에 집중할 것이다. Why는 너무 명확하고 쉬운 이유이기 때문이다. (프로그램 사용을 쉽게 하기 위해)


**CPU 가상화**
프로그램들을 여러 개 실행시키면 프로세서가 하나 밖에 없음애도 프로그램 여러 개가 동시에 실행되는 것 처럼 보인다. 이는 운영체제의 CPU 가상화(cpu virtualization)에 의한 것으로 운영체제는 하드웨어의 도움을 받아 시스템에 수많은 CPU가 존재하는 듯한 **환상(illusion)** 을 만들어낸다.

**Memory 가상화**
물리 메모리 모델은 단순한 바이트 배열이다. 메모리를 읽고 쓰기 위해서는 주소(address)를 명시해야 한다. 프로그램들이 실행되는 동안 메모리는 항상 접근되는데 이 때 각자 자신의 독립적인 메모리 공간을 가지고 있는 것 처럼 보인다.
이는 운영체제의 메모리 가상화(memory virtualization)에 의한 것으로 각 프로세스는 자신만의 가상 주소 공간(virtual address space)을 갖는다.
운영체제는 이 가상 주소 공간을 물리 메모리로 매핑(mapping)한다.

### 병행성 (Concurrency)

시스템이 자원 공유 및 상호작용 관리를 통해 여러 작업을 수행할 수 있는 능력이다.
운영체제는 한 번에 여러 가지 프로세스를 저글링하여 하나의 프로세스를 실행하고, 그 다음 다른 프로세스를 실행한다.
이 과정에서 발생하는 문제들을 **병행성 문제(the problems of concurrency)** 라고 한다.

### 영속성 (Persistence)

DRAM 같은 휘발성(volatile) 메모리에 저장된 데이터는 쉽게 손실될 수 있다. 그러므로 데이터를 **영속적으로(persistently)** 저장할 수 있는 하드웨어와 소프트웨어가 필요하다.
하드웨어는 HDD나 SSD 같은 입출력 장치 형태로 제공된다.
이러한 디스크를 관리하는 운영체제 소프트웨어를 **파일 시스템(file system)**이라고 부른다. 파일 시스템은 사용자가 생성한 파일(file)을 시스템의 디스크에 안전하고 효율적인 방식으로 저장한다.
CPU나 메모리와 달리 디스크는 프로그램 별로 가상 디스크를 생성하지 않는다.

> 즉, 운영체제는 하드웨어와 사용자의 프로그램 사이에서 중재자 역할을 수행하는 **자원 관리자**다.

## 운영체제 설계 목표

운영체제는 CPU, 메모리, 디스크 등의 물리 자원을 **가상화(virtualization)** 한다. **병행성(concurrency)**과 관련된 복잡한 문제를 처리하며 파일을 **영속성(persistence)** 있게 저장한다.

이러한 시스템을 구현하려면 몇 가지 목표가 필요하다.

### 목표

> **1. 추상화(abstraction)**

시스템을 사용하기 쉽도록 하기 위해 몇 가지 개념들을 정의해야 한다. 추상화는 컴퓨터 과학에서 모든 일의 근간으로 **거대한 프로그램**을 **작고 이해하기 쉬운 조각들로** 나누어 구현할 수 있게 한다.
추상화 덕분에 어셈블리어를 할 줄 몰라도 C 같은 고수준(high-level) 언어로 프로그램을 작성할 수 있고, 트랜지스터에 대한 지식 없이도 게이트를 이용하여 프로세서를 만들 수 있다.

> **2. 성능(performance)**

운영체제의 설계와 구현에 중요한 목표는 성능.
즉, **오버헤드를 최소화(minimize the overheads)** 하는 것이다.
가상화와 사용하기 쉬운 시스템을 만드는 것은 의미가 있지만, 어떤 비용을 치뤄서라도 해내야하는 것은 아니다. 가상화 및 다른 운영체제의 기능들은 과도한 오버헤드 없이 제공되어야 한다.

> **3. 보호(protection)**

또 다른 목표는 응용 프로그램과 응용 프로그램 간, 그리고 운영체제와 응용 프로그램 간의 보호다. 다수의 프로그램들이 동시에 실행되기 때문에, 운영체제는 한 프로그램의 악의적인 또는 의도치 않은 행위가 다른 프로그램에게 피해를 주지 않을 것을 보장해야 한다. 또한 응용 프로그램이 운영체제에 해를 끼치는 것도 방지해야 한다. 보호는 운영체제의 원칙 중 하나인 **고립(isolation)** 의 핵심이다. 프로세스를 다른 프로세스로부터 고립시키는 일은 보호의 핵심이고 운영체제가 수행 해야 할 일 중 많은 부분의 근간이 된다.

> **4. 신뢰성(reliability)**

운영체제는 반드시 멈추지 않고 계속 실행되어야 한다. 운영체제 실행에 실패하면 시스템의 다른 모든 응용 프로그램도 실패하게 된다. 이러한 종속성 때문에, 운영체제는 높은 수준의 신뢰성을 제공해야 한다.

> **5. 에너지 효율성(energy-efficiency)**

우리의 녹색 세상을 위해 중요하다.

> **6. 보안(security)**

악의적인 응용 프로그램에 대한 보안은 현재와 같은 네트워크 환경에서 특히 중요하다.

> **7. 이동성(mobility)**

작은 장치에서 사용되는 운영체제일 수록 중요해진다.

---
<span style="color:gray"><참고자료>
Remzi Arpaci-Dusseau and Andrea C. Arpaci-Dusseau, Operating System: Three Easy Pieces, Arpaci-Dusseau Books </span>
